<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wil-Bot | Intelligent Process Mining Assistant</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #050505;
      --panel-bg: #0a0a0a;
      --border-color: #222;
      --text-primary: #eee;
      --text-secondary: #888;
      --accent-glow: rgba(255, 255, 255, 0.15);
      --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    * { box-sizing: border-box; outline: none; }
    canvas { background: #000; }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-primary);
      font-family: var(--font-family);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      display: flex;
    }

    /* LEFT PANEL: VISUALIZATION */
    #viz-panel {
      flex: 7; /* 70% */
      position: relative;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at center, #111 0%, #000 100%);
      cursor: grab;
    }
    #viz-panel:active { cursor: grabbing; }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
    }

    /* Camera UI */
    #cam-ui {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
    }

    #cam-toggle {
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.3s;
      backdrop-filter: blur(4px);
    }
    #cam-toggle:hover { background: rgba(255,255,255,0.1); color: white; }
    #cam-toggle.active { border-color: white; color: white; background: rgba(255,255,255,0.1); }

    #cam-preview-wrapper {
      width: 120px;
      height: 90px;
      background: #000;
      border: 1px solid #333;
      border-radius: 8px;
      overflow: hidden;
      display: none; /* Hidden by default */
      position: relative;
    }
    #cam-preview-wrapper video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* Mirror */
    }
    #emotion-indicator {
      position: absolute;
      bottom: 4px;
      left: 4px;
      font-size: 10px;
      background: rgba(0,0,0,0.7);
      padding: 2px 6px;
      border-radius: 4px;
      color: white;
      pointer-events: none;
    }

    /* Topic Dots (DOM Overlay) */
    .topic-dot {
      position: absolute;
      width: 12px;
      height: 12px;
      background: white;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px white, 0 0 20px rgba(255,255,255,0.5);
      cursor: pointer;
      transition: opacity 0.3s, box-shadow 0.2s, transform 0.2s;
      pointer-events: auto;
      z-index: 5;
    }
    /* Enlarged hit-area */
    .topic-dot::before {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 48px;
      height: 48px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: transparent;
      pointer-events: auto;
    }
    .topic-dot:hover {
      transform: translate(-50%, -50%) scale(1.2);
      box-shadow: 0 0 12px white, 0 0 28px rgba(255,255,255,0.6);
    }
    .topic-dot:hover::before { background: rgba(255,255,255,0.05); }
    .topic-tooltip {
      position: absolute;
      bottom: 32px;
      left: 50%;
      transform:
        translateX(-50%)
        scale(calc(1 / var(--dot-scale, 1)));
      transform-origin: bottom center;
      background: rgba(0, 0, 0, 0.92);
      border: 1px solid #555;
      border-radius: 14px;
      padding: 12px 16px;
      font-size: 14px;
      line-height: 1.45;
      min-width: 260px;
      max-width: 360px;
      color: #f0f0f0;
      white-space: normal;
      box-shadow:
        0 12px 35px rgba(0,0,0,0.6),
        0 0 0 1px rgba(255,255,255,0.05);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
      z-index: 10;
    }
    .topic-tooltip strong {
      display: block;
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.3px;
      margin-bottom: 0;
      color: #ffffff;
    }
    .topic-summary {
      display: block;
      font-size: 14px;
      line-height: 1.35;
      margin-top: 4px;
      color: #e6e6e6;
    }
    .topic-tooltip::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: rgba(0,0,0,0.92) transparent transparent transparent;
    }
    .topic-dot:hover .topic-tooltip { opacity: 1; }

    /* RIGHT PANEL: CHAT */
    #chat-panel {
      flex: 3; /* 30% */
      background-color: var(--panel-bg);
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      position: relative;
      box-shadow: -5px 0 20px rgba(0,0,0,0.5);
      z-index: 20;
    }

    #chat-header {
      padding: 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #chat-title { font-size: 16px; font-weight: 600; letter-spacing: 0.5px; }
    #chat-status { font-size: 11px; color: var(--text-secondary); display: flex; align-items: center; gap: 6px; }
    .status-dot { width: 6px; height: 6px; border-radius: 50%; background: #444; }
    .status-dot.active { background: #0f0; box-shadow: 0 0 5px #0f0; }

    #messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Scrollbar */
    #messages-container::-webkit-scrollbar { width: 6px; }
    #messages-container::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

    .message {
      max-width: 90%;
      line-height: 1.5;
      font-size: 14px;
      animation: fadeIn 0.3s ease-out;
    }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    .msg-bot { align-self: flex-start; color: #ddd; }
    .msg-user { align-self: flex-end; color: white; background: #222; padding: 10px 14px; border-radius: 12px; border-bottom-right-radius: 2px; }
    .msg-bot .content { background: transparent; padding: 0; }

    /* Suggested Chips */
    #chips-container {
      padding: 0 20px 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      min-height: 32px;
    }
    .chip {
      background: rgba(255,255,255,0.05);
      border: 1px solid #333;
      border-radius: 16px;
      padding: 4px 12px;
      font-size: 11px;
      color: #aaa;
      cursor: pointer;
      transition: all 0.2s;
    }
    .chip:hover { border-color: #666; color: white; background: rgba(255,255,255,0.1); }

    /* Input Area */
    #input-area {
      padding: 20px;
      border-top: 1px solid var(--border-color);
      background: var(--panel-bg);
    }
    .input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }
    #user-input {
      width: 100%;
      background: #111;
      border: 1px solid #333;
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 14px;
      transition: border 0.3s;
    }
    #user-input:focus { border-color: #666; }
    #send-btn {
      position: absolute;
      right: 8px;
      background: transparent;
      border: none;
      color: white;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.2s;
    }
    #send-btn:hover { opacity: 1; }

    /* Detection Indicator in Chat */
    #detected-emotion {
      font-size: 10px;
      margin-top: 4px;
      opacity: 0;
      transition: opacity 0.5s;
    }
    .emotion-happy { color: #88ffaa; }
    .emotion-confused { color: #ffaa88; }

    /* Loading Indicator */
    .typing-indicator span {
      display: inline-block;
      width: 4px;
      height: 4px;
      background: #888;
      border-radius: 50%;
      margin: 0 2px;
      animation: bounce 1.4s infinite ease-in-out both;
    }
    .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
    .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

    #chips-container,
    #chips-container .chip,
    #input-area,
    #user-input,
    #send-btn {
      font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    #user-input {
      font-weight: 400;
      letter-spacing: 0.1px;
    }

    .chip {
      font-weight: 500;
      letter-spacing: 0.2px;
    }

    /* ===============================
       INTRO VIDEO
    ================================ */

    #intro {
      position: fixed;
      inset: 0;
      background: black;
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 0.8s ease;
    }

    #intro video {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
    }

    #intro video::-webkit-media-controls {
      display: none !important;
    }

    #intro video {
      pointer-events: none;
    }

    #start-sound {
      position: absolute;
      bottom: 40px;
      left: 40px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      backdrop-filter: blur(6px);
    }
    #start-sound:hover { background: rgba(255,255,255,0.25); }

    #skip-intro {
      position: absolute;
      bottom: 40px;
      right: 40px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      backdrop-filter: blur(6px);
    }

    #skip-intro:hover {
      background: rgba(255,255,255,0.25);
    }

    /* скрываем интро после окончания */
    body.intro-finished #intro {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <!-- INTRO VIDEO OVERLAY -->
  <div id="intro">
    <video id="intro-video" autoplay muted playsinline>
      <source src="Wilbot_Intro3.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>

    <button id="start-sound">Start with sound</button>
    <button id="skip-intro">Skip</button>
  </div>

  <!-- VISUALIZATION PANEL -->
  <div id="viz-panel">
    <canvas id="point-cloud"></canvas>

    <div id="cam-ui">
      <button id="cam-toggle">Enable Camera</button>
      <div id="cam-preview-wrapper">
        <video id="webcam" autoplay playsinline></video>
        <div id="emotion-indicator">Neutral</div>
      </div>
    </div>

    <div id="dots-layer"></div>
  </div>

  <!-- CHAT PANEL -->
  <div id="chat-panel">
    <div id="chat-header">
      <div>
        <div id="chat-title">Wil-Bot</div>
        <div id="detected-emotion"></div>
      </div>
      <div id="chat-status"><div class="status-dot"></div> Idle</div>
    </div>

    <div id="messages-container">
      <div class="message msg-bot">
        <div class="content">Hi, I‘m Wil-bot what is your first question?</div>
      </div>
    </div>

    <div id="chips-container"></div>

    <div id="input-area">
      <div class="input-wrapper">
        <input type="text" id="user-input" placeholder="Type a message..." autocomplete="off" />
        <button id="send-btn" aria-label="Send">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
               stroke-linecap="round" stroke-linejoin="round">
            <line x1="22" y1="2" x2="11" y2="13"></line>
            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <script type="module">
    import { FilesetResolver, FaceLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm";

    const CONFIG = {
      // ✅ Adjusted to your real webhook URL (from above)
      N8N_WEBHOOK: "http://localhost:5678/webhook/135e0fa6-8d2d-4c47-ad5b-72eab3292936",
      PARTICLE_COUNT: 4500,
      SPHERE_RADIUS: 250,
      CAMERA_SMOOTHING: 20,
      TOPIC_THRESHOLD: 0.2,
      SPINNER_RATIO: 0.03,       // 3% частиц будут “спиннерами”
      SPINNER_RADIUS_BOOST: 1.15 // чуть дальше от центра, чтобы их было видно
    };

    const STATE = {
      sessionId: localStorage.getItem('wilbot_session') || generateUUID(),
      particles: [],
      topics: [],
      messages: [],
      activeTopicId: null,
      emotion: 'neutral',
      isTyping: false,
      isSpeaking: false,
      audioContext: null,
      analyser: null,
      dataArray: null,
      rotation: { x: 0, y: 0 },
      targetRotation: { x: 0, y: 0 },
      scatter: 0,
      lastLandmarks: null,
      cameraEnabled: false,
      faceLandmarker: null,
      isThinking: false,
      dust: 0,          // 0..1 (0 = sphere, 1 = dust)
      happyPulse: 0,     // 0..1 (короткий “всплеск” когда happy)
      happyTarget: 0
    };

    if (!localStorage.getItem('wilbot_session')) {
      localStorage.setItem('wilbot_session', STATE.sessionId);
    }

    // DOM Elements
    const canvas = document.getElementById('point-cloud');
    const ctx = canvas.getContext('2d');
    const dotsLayer = document.getElementById('dots-layer');
    const msgsContainer = document.getElementById('messages-container');
    const input = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');
    const chipsContainer = document.getElementById('chips-container');
    const statusDot = document.querySelector('.status-dot');
    const statusText = document.querySelector('#chat-status');
    const emotionLabel = document.getElementById('detected-emotion');
    const webcamVideo = document.getElementById('webcam');
    const camToggle = document.getElementById('cam-toggle');
    const camPreview = document.getElementById('cam-preview-wrapper');
    const emotionDebug = document.getElementById('emotion-indicator');

    function init() {
      resize();
      createParticles();
      window.addEventListener('resize', resize);
      setupInput();
      animate();
      setupCamera();
    }

    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    function createParticles() {
      const N = CONFIG.PARTICLE_COUNT;
      const R = CONFIG.SPHERE_RADIUS;

      const rand = (a, b) => a + Math.random() * (b - a);

      function randomInUnitSphere() {
        while (true) {
          const x = rand(-1, 1);
          const y = rand(-1, 1);
          const z = rand(-1, 1);
          const r2 = x * x + y * y + z * z;
          if (r2 > 0 && r2 <= 1) return { x, y, z };
        }
      }

      function pointOnSphere(i) {
        const phi = Math.acos(1 - 2 * (i + 0.5) / N);
        const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
        return {
          x: R * Math.sin(phi) * Math.cos(theta),
          y: R * Math.sin(phi) * Math.sin(theta),
          z: R * Math.cos(phi)
        };
      }

      function pointInDust() {
        const v = randomInUnitSphere();
        const dustScale = R * 1.6;
        const radial = Math.pow(Math.random(), 0.35) * dustScale;
        return { x: v.x * radial, y: v.y * radial, z: v.z * radial };
      }

      STATE.particles = new Array(N);

      const spinnerRatio = (typeof CONFIG.SPINNER_RATIO === "number") ? CONFIG.SPINNER_RATIO : 0.015;

      for (let i = 0; i < N; i++) {
        const s = pointOnSphere(i);
        const d = pointInDust();

        STATE.particles[i] = {
          x: s.x, y: s.y, z: s.z,
          baseX: s.x, baseY: s.y, baseZ: s.z,
          dustX: d.x, dustY: d.y, dustZ: d.z,

          size: rand(0.5, 2.0),
          phase: rand(0, Math.PI * 2),
          jitter: { x: 0, y: 0, z: 0 },

          driftSpeed: rand(0.4, 2.0),
          driftAmp: rand(6, 24),
          driftPhase: rand(0, Math.PI * 2),

          isSpinner: Math.random() < spinnerRatio,
          orbitDir: Math.random() < 0.5 ? -1 : 1,
          orbitSeed: rand(0, Math.PI * 2),
          orbitSpeed: rand(0.6, 3.2),
          orbitTiltA: rand(-Math.PI, Math.PI),
          orbitTiltB: rand(-Math.PI, Math.PI),
          orbitRadiusK: rand(1.05, 1.55)
        };
      }
    }

    function resize() {
      canvas.width = document.getElementById('viz-panel').offsetWidth;
      canvas.height = document.getElementById('viz-panel').offsetHeight;
      STATE.centerX = canvas.width / 2;
      STATE.centerY = canvas.height / 2;
    }

    function smooth(a, b, x) {
      const u = Math.max(0, Math.min(1, (x - a) / (b - a)));
      return u * u * (3 - 2 * u);
    }

    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'rgba(5, 5, 5, 0.35)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      let audioLevel = 0;
      if (STATE.isSpeaking && STATE.analyser) {
        STATE.analyser.getByteFrequencyData(STATE.dataArray);
        let sum = 0;
        for (let i = 0; i < STATE.dataArray.length; i++) sum += STATE.dataArray[i];
        audioLevel = sum / STATE.dataArray.length / 256;
      } else if (STATE.isSpeaking) {
        audioLevel = (Math.sin(time * 10) + 1) / 4;
      }

      const rotSpeed = STATE.isTyping ? 0.005 : 0.001;
      STATE.targetRotation.y += rotSpeed;
      STATE.rotation.x += (STATE.targetRotation.x - STATE.rotation.x) * 0.05;
      STATE.rotation.y += (STATE.targetRotation.y - STATE.rotation.y) * 0.05;

      let scatterAmt = Math.min(STATE.scatter, 0.12);
      let lift = 0;

      if (STATE.emotion === 'confused') {
        scatterAmt = Math.max(scatterAmt, 0.10);
      }

      if (STATE.emotion === 'happy') {
        lift = -5;
        scatterAmt += 0.03;
      }

      if (STATE.scatter > 0) STATE.scatter -= 0.02;
      if (STATE.scatter < 0) STATE.scatter = 0;

      const fov = 800;

      ctx.globalCompositeOperation = 'lighter';

      const dustTarget = STATE.isThinking ? 1 : 0;
      STATE.dust += (dustTarget - STATE.dust) * 0.06;

      STATE.happyTarget = (STATE.emotion === 'happy') ? 1 : 0;
      STATE.happyPulse += (STATE.happyTarget - STATE.happyPulse) * 0.06;

      STATE.particles.forEach(p => {
        let sx = p.baseX, sy = p.baseY, sz = p.baseZ;

        let dx = p.dustX, dy = p.dustY, dz = p.dustZ;

        const swirl = 18 * STATE.dust;
        dx += Math.sin(time + p.phase) * swirl;
        dy += Math.cos(time * 0.7 + p.phase) * swirl;
        dz += Math.sin(time * 0.9 + p.phase) * swirl;

        let tx = sx * (1 - STATE.dust) + dx * STATE.dust;
        let ty = sy * (1 - STATE.dust) + dy * STATE.dust;
        let tz = sz * (1 - STATE.dust) + dz * STATE.dust;

        if (STATE.emotion === 'happy') {
          const e = 0.35 + 0.65 * STATE.happyPulse;
          const breathe = 1 + Math.sin(time * (1.6 + 0.35 * p.driftSpeed) + p.phase) * (0.05 * e);
          tx *= breathe; ty *= breathe; tz *= breathe;

          ty += Math.sin(time * 2.2 + p.phase * 1.7) * (14 * e);
          tx += Math.cos(time * 1.7 + p.phase * 1.1) * (10 * e);
          tz += Math.sin(time * 1.9 + p.phase * 1.3) * (10 * e);

          const ang = Math.sin(time * 1.1 + p.phase) * (0.18 * e);
          const c = Math.cos(ang), s = Math.sin(ang);
          const tx2 = tx * c - tz * s;
          const tz2 = tz * c + tx * s;
          tx = tx2; tz = tz2;
        }

        if (STATE.dust > 0.001) {
          const s = p.driftSpeed;
          const a = p.driftAmp * STATE.dust;
          tx += Math.sin(time * 0.9 * s + p.driftPhase) * a;
          ty += Math.cos(time * 0.7 * s + p.driftPhase * 1.3) * a * 0.8;
          tz += Math.sin(time * 0.6 * s + p.driftPhase * 0.8) * a;
        }

        if (STATE.isThinking && p.isSpinner) {
          const t = time * (0.28 + p.orbitSpeed * 0.18);
          const phase = (t * 0.06 + p.orbitSeed / (Math.PI * 2)) % 1;

          const fastStart = 0.78;
          const fastEnd = 0.88;
          const accel = smooth(fastStart, fastEnd, phase);

          const baseAng = t * 0.75;
          const glideAng = t * (1.6 + p.orbitSpeed * 0.9) * accel;

          const ang = p.orbitDir * (baseAng + glideAng);

          const bank = 0.35 * accel;
          const tiltA = p.orbitTiltA + bank;
          const tiltB = p.orbitTiltB - bank;

          const R = CONFIG.SPHERE_RADIUS * p.orbitRadiusK;

          let ox = Math.cos(ang) * R;
          let oy = 0;
          let oz = Math.sin(ang) * R;

          const ca = Math.cos(tiltA), sa = Math.sin(tiltA);
          const cb = Math.cos(tiltB), sb = Math.sin(tiltB);

          let y1 = oy * ca - oz * sa;
          let z1 = oz * ca + oy * sa;
          let x1 = ox;

          let x2 = x1 * cb - y1 * sb;
          let y2 = y1 * cb + x1 * sb;
          let z2 = z1;

          const wobble = (0.04 + 0.14 * accel) * CONFIG.SPHERE_RADIUS;
          x2 += Math.sin(t * 2.1 + p.orbitSeed) * wobble;
          y2 += Math.cos(t * 1.7 + p.orbitSeed) * wobble * 0.7;
          z2 += Math.sin(t * 1.9 + p.orbitSeed) * wobble;

          const lock = 0.55 + 0.35 * accel;

          tx = tx * (1 - lock) + x2 * lock;
          ty = ty * (1 - lock) + y2 * lock;
          tz = tz * (1 - lock) + z2 * lock;
        }

        const pulse = 1 + (audioLevel * 0.8) + (Math.sin(time + p.phase) * 0.02);
        tx *= pulse; ty *= pulse; tz *= pulse;
        ty += lift;

        if (STATE.emotion === 'confused') {
          p.jitter.x += (Math.random() - 0.5) * 1.2;
          p.jitter.y += (Math.random() - 0.5) * 1.2;
          p.jitter.z += (Math.random() - 0.5) * 1.2;
          p.jitter.x *= 0.9; p.jitter.y *= 0.9; p.jitter.z *= 0.9;
        } else {
          p.jitter.x = p.jitter.y = p.jitter.z = 0;
        }

        p.x += (tx - p.x) * 0.1 + p.jitter.x;
        p.y += (ty - p.y) * 0.1 + p.jitter.y;
        p.z += (tz - p.z) * 0.1 + p.jitter.z;

        let x = p.x, z = p.z;

        const cosY = Math.cos(STATE.rotation.y), sinY = Math.sin(STATE.rotation.y);
        const rx = x * cosY - z * sinY;
        const rz = z * cosY + x * sinY;

        const cosX = Math.cos(STATE.rotation.x), sinX = Math.sin(STATE.rotation.x);
        const ry = p.y * cosX - rz * sinX;
        const rzFinal = rz * cosX + p.y * sinX;

        const scale = fov / (fov + rzFinal + 500);
        const x2d = rx * scale + STATE.centerX;
        const y2d = ry * scale + STATE.centerY;

        if (scale > 0) {
          const alpha = Math.min(1, (rzFinal + CONFIG.SPHERE_RADIUS) / (CONFIG.SPHERE_RADIUS * 2));
          let size = p.size * scale;
          if (STATE.isThinking && p.isSpinner) size *= 1.8;

          ctx.beginPath();
          ctx.arc(x2d, y2d, size, 0, Math.PI * 2);
          let extraAlpha = 0;
          if (STATE.isThinking && p.isSpinner) extraAlpha = 0.35;

          ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, alpha + extraAlpha)})`;
          ctx.fill();
        }
      });

      ctx.globalCompositeOperation = 'source-over';
      drawTopicConnections(fov);
      updateTopicDots(fov);
    }

    // Drag to rotate
    let isDragging = false;
    let didDrag = false;
    let lastMouse = { x: 0, y: 0 };
    const vizPanel = document.getElementById('viz-panel');

    vizPanel.addEventListener('mousedown', e => { isDragging = true; didDrag = false; lastMouse = { x: e.clientX, y: e.clientY }; });
    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = e.clientX - lastMouse.x;
      const dy = e.clientY - lastMouse.y;
      if (Math.abs(dx) + Math.abs(dy) > 3) didDrag = true;
      STATE.targetRotation.y += dx * 0.005;
      STATE.targetRotation.x += dy * 0.005;
      lastMouse = { x: e.clientX, y: e.clientY };
    });

    vizPanel.addEventListener('click', (e) => {
      // Click on empty space (not on a node): jump to the latest state of the chat
      if (didDrag) return;
      const isDot = e.target && (e.target.classList?.contains('topic-dot') || e.target.closest?.('.topic-dot'));
      if (!isDot) scrollToBottom();
    });

    function project3D(pos, fov) {
      const { x, y, z } = pos;

      const cosY = Math.cos(STATE.rotation.y), sinY = Math.sin(STATE.rotation.y);
      const rx = x * cosY - z * sinY;
      const rz = z * cosY + x * sinY;

      const cosX = Math.cos(STATE.rotation.x), sinX = Math.sin(STATE.rotation.x);
      const ry = y * cosX - rz * sinX;
      const rzFinal = rz * cosX + y * sinX;

      const scale = fov / (fov + rzFinal + 500);

      return {
        x: rx * scale + STATE.centerX,
        y: ry * scale + STATE.centerY,
        z: rzFinal,
        scale
      };
    }

    function drawTopicConnections(fov) {
      if (STATE.topics.length < 2) return;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 0.5;

      for (let i = 1; i < STATE.topics.length; i++) {
        const a = project3D(STATE.topics[i - 1].pos, fov);
        const b = project3D(STATE.topics[i].pos, fov);

        if (a.z < -450 || b.z < -450) continue;

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }

      ctx.restore();
    }

    function updateTopicDots(fov) {
      STATE.topics.forEach(topic => {
        const x = topic.pos.x, y = topic.pos.y, z = topic.pos.z;

        const cosY = Math.cos(STATE.rotation.y), sinY = Math.sin(STATE.rotation.y);
        const rx = x * cosY - z * sinY;
        const rz = z * cosY + x * sinY;

        const cosX = Math.cos(STATE.rotation.x), sinX = Math.sin(STATE.rotation.x);
        const ry = y * cosX - rz * sinX;
        const rzFinal = rz * cosX + y * sinX;

        const scale = fov / (fov + rzFinal + 500);
        const x2d = rx * scale + STATE.centerX;
        const y2d = ry * scale + STATE.centerY;

        const el = document.getElementById(`topic-${topic.id}`);
        if (el) {
          if (rzFinal > -400) {
            el.style.display = 'block';
            el.style.left = `${x2d}px`;
            el.style.top = `${y2d}px`;
            el.style.setProperty('--dot-scale', scale);
            el.style.transform = `translate(-50%, -50%) scale(${scale})`;
            el.style.opacity = Math.min(1, (rzFinal + 500) / 500);
          } else {
            el.style.display = 'none';
          }
        }
      });
    }

    function createTopic(title, summary, firstIndex) {
      STATE.scatter = 1.0;

      const id = Date.now();
      const radius = CONFIG.SPHERE_RADIUS * 1.5;
      const phi = Math.random() * Math.PI * 2;
      const theta = Math.random() * Math.PI;

      const pos = {
        x: radius * Math.sin(theta) * Math.cos(phi),
        y: radius * Math.sin(theta) * Math.sin(phi),
        z: radius * Math.cos(theta)
      };

      const topic = {
        id,
        title,
        summary,
        pos,
        firstIndex: (typeof firstIndex === 'number') ? firstIndex : null,
        lastIndex: (typeof firstIndex === 'number') ? firstIndex : null
      };

      STATE.topics.push(topic);
      STATE.activeTopicId = id;

      const el = document.createElement('div');
      el.id = `topic-${id}`;
      el.className = 'topic-dot';
      el.innerHTML = `
        <div class="topic-tooltip">
          <strong>${title}</strong>
          <span class="topic-summary">${summary}</span>
        </div>
      `;

      // Click on the node: jump to where this topic was first discussed
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        if (topic.firstIndex !== null) {
          scrollToMessage(topic.firstIndex, 'start');
        }
      });

      dotsLayer.appendChild(el);
    }

    const STOP_WORDS = new Set(['the','and','is','a','an','in','on','of','to','for','it','this','that','i','you']);
    let lastKeywords = new Set();

    function checkNewTopic(text) {
      const words = text.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
      const keywords = new Set(words.filter(w => w.length > 3 && !STOP_WORDS.has(w)));

      if (lastKeywords.size > 0) {
        let overlap = 0;
        keywords.forEach(k => { if (lastKeywords.has(k)) overlap++; });
        const union = new Set([...keywords, ...lastKeywords]).size;
        const jaccard = union === 0 ? 0 : overlap / union;

        if (jaccard < CONFIG.TOPIC_THRESHOLD) {
          const title = Array.from(keywords).slice(0, 2).join(' ').toUpperCase();
          createTopic(title, "Analysis context switched.", STATE.messages.length - 1);
        }
      }
      if (keywords.size > 0) lastKeywords = keywords;
    }

    function setupInput() {
      input.addEventListener('keydown', e => {
        if (e.key === 'Enter') sendMessage();
        STATE.isTyping = input.value.length > 0;
      });
      input.addEventListener('keyup', () => {
        STATE.isTyping = input.value.length > 0;
      });
      sendBtn.addEventListener('click', sendMessage);
    }

    async function sendMessage(overrideText = null) {
      const text = overrideText || input.value.trim();
      if (!text) return;

      addMessage('user', text);
      input.value = '';
      STATE.isTyping = false;
      checkNewTopic(text);

      statusDot.classList.add('active');
      statusDot.style.background = '#fb0';
      statusText.childNodes[1].textContent = " Thinking...";
      STATE.isThinking = true;
      STATE.scatter = Math.max(STATE.scatter, 0.7);

      // ✅ Flat JSON payload
      const payload = {
        user_message: text,
        session_id: STATE.sessionId,
        current_shape: "sphere",
        emotion_state: STATE.emotion
      };

      try {
        const res = await fetch(CONFIG.N8N_WEBHOOK, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const raw = await res.text();
        console.log("Webhook status:", res.status, res.statusText);
        console.log("Webhook raw response:", raw);

        if (!res.ok) {
          throw new Error(`Webhook error ${res.status}: ${raw || res.statusText}`);
        }

        if (!raw || raw.trim() === "") {
          setTimeout(() => handleBotResponse({ response: "", audio_url: null }), 300);
          return;
        }

        let parsed;
        try { parsed = JSON.parse(raw); }
        catch { parsed = { response: raw }; }

        setTimeout(() => handleBotResponse(parsed), 300);

      } catch (err) {
        console.error(err);
        addMessage('bot', "Connection error. Please check the console or try again.");
        statusDot.classList.remove('active');
        statusText.childNodes[1].textContent = " Error";
        STATE.isThinking = false;
      }
    }

    function addMessage(role, text) {
      // Keep an indexed log of messages so we can jump to exact points in the chat
      const index = STATE.messages.length;
      const id = `msg-${index}`;
      STATE.messages.push({ id, role, text: String(text) });

      const div = document.createElement('div');
      div.className = `message msg-${role}`;
      div.id = id;
      div.dataset.msgIndex = String(index);
      div.innerHTML = `<div class="content">${escapeHTML(text)}</div>`;
      msgsContainer.appendChild(div);

      // Update "last seen" index for the currently active topic (if any)
      if (STATE.activeTopicId) {
        const t = STATE.topics.find(x => x.id === STATE.activeTopicId);
        if (t) t.lastIndex = index;
      }

      msgsContainer.scrollTop = msgsContainer.scrollHeight;
    }

    function escapeHTML(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function scrollToMessage(index, align = 'start') {
      const el = document.getElementById(`msg-${index}`);
      if (!el) return;

      el.scrollIntoView({ behavior: 'smooth', block: align });

      // quick highlight
      el.style.transition = 'box-shadow 0.2s, background 0.2s';
      const prevBg = el.style.background;
      el.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.25)';
      if (!el.classList.contains('msg-user')) el.style.background = 'rgba(255,255,255,0.04)';
      setTimeout(() => {
        el.style.boxShadow = '';
        el.style.background = prevBg;
      }, 3000);
    }

    function scrollToBottom() {
      msgsContainer.scrollTo({ top: msgsContainer.scrollHeight, behavior: 'smooth' });
    }

    function handleBotResponse(data) {
      STATE.isThinking = false;
      STATE.scatter = Math.max(STATE.scatter, 0.9);

      const obj = Array.isArray(data) ? (data[0] ?? {}) : (data ?? {});
      const botText = (
        obj.response ??
        obj.output ??
        obj.text ??
        obj.answerText ??
        obj.message ??
        ""
      ).toString();

      statusDot.style.background = '#0f0';
      statusText.childNodes[1].textContent = " Speaking...";

      if (!botText.trim()) {
        console.warn("Empty bot response payload:", obj);
        addMessage('bot', "(No response text returned from webhook)");
        STATE.isSpeaking = false;
        statusDot.classList.remove('active');
        statusText.childNodes[1].textContent = " Idle";
        return;
      }

      addMessage('bot', botText);

      const audioUrl =
        obj.audio_url ??
        obj.audioUrl ??
        obj.tts_url ??
        obj.ttsUrl ??
        null;

      if (audioUrl) {
        playAudio(audioUrl);
      } else {
        const wordCount = botText.trim().split(/\s+/).length;
        const readingTime = (wordCount / 3) * 1000;

        STATE.isSpeaking = true;
        setTimeout(() => {
          STATE.isSpeaking = false;
          statusDot.classList.remove('active');
          statusText.childNodes[1].textContent = " Idle";
        }, Math.max(2000, readingTime));
      }
    }

    function playAudio(url) {
      if (!STATE.audioContext) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        STATE.audioContext = new AudioContext();
        STATE.analyser = STATE.audioContext.createAnalyser();
        STATE.analyser.fftSize = 64;
        STATE.dataArray = new Uint8Array(STATE.analyser.frequencyBinCount);
      }

      const audio = new Audio(url);
      audio.crossOrigin = "anonymous";

      const source = STATE.audioContext.createMediaElementSource(audio);
      source.connect(STATE.analyser);
      STATE.analyser.connect(STATE.audioContext.destination);

      STATE.isSpeaking = true;
      audio.play().catch(e => console.warn("Audio play blocked", e));

      audio.onended = () => {
        STATE.isSpeaking = false;
        statusDot.classList.remove('active');
        statusText.childNodes[1].textContent = " Idle";
      };
    }

    function updateChips(emotion) {
      chipsContainer.innerHTML = '';
      const chips = [];

      if (emotion === 'confused') chips.push('Explain simpler', 'Give example', 'Start over');
      else if (emotion === 'happy') chips.push('Next step', 'Go deeper', 'Show details');
      else chips.push('Analyze variant', 'Process deviations', 'Cycle time');

      chips.forEach(txt => {
        const btn = document.createElement('div');
        btn.className = 'chip';
        btn.textContent = txt;
        btn.onclick = () => sendMessage(txt);
        chipsContainer.appendChild(btn);
      });
    }
    updateChips('neutral');

    // CAMERA / MEDIAPIPE (unchanged)
    async function setupCamera() {
      camToggle.addEventListener('click', async () => {
        if (STATE.cameraEnabled) {
          STATE.cameraEnabled = false;
          camToggle.classList.remove('active');
          camToggle.textContent = "Enable Camera";
          camPreview.style.display = 'none';
          if (webcamVideo.srcObject) webcamVideo.srcObject.getTracks().forEach(t => t.stop());
          emotionLabel.style.opacity = 0;
          return;
        }

        try {
          if (!STATE.faceLandmarker) {
            const filesetResolver = await FilesetResolver.forVisionTasks(
              "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            STATE.faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
              baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                delegate: "GPU"
              },
              outputFaceBlendshapes: true,
              runningMode: "VIDEO",
              numFaces: 1
            });
          }

          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          webcamVideo.srcObject = stream;
          webcamVideo.addEventListener("loadeddata", predictWebcam);

          STATE.cameraEnabled = true;
          camToggle.classList.add('active');
          camToggle.textContent = "Camera On";
          camPreview.style.display = 'block';

        } catch (e) {
          console.error("Camera/Model Error", e);
          alert("Could not enable camera. Check permissions or console.");
        }
      });
    }

    const emotionHistory = [];
    const HISTORY_SIZE = 25;
    let lastVideoTime = -1;

    async function predictWebcam() {
      if (!STATE.cameraEnabled) return;

      let startTimeMs = performance.now();
      if (lastVideoTime !== webcamVideo.currentTime) {
        lastVideoTime = webcamVideo.currentTime;
        const results = STATE.faceLandmarker.detectForVideo(webcamVideo, startTimeMs);

        if (results.faceBlendshapes && results.faceBlendshapes.length > 0) {
          const shapes = results.faceBlendshapes[0].categories;
          const getScore = (name) => shapes.find(s => s.categoryName === name)?.score || 0;

          const smile = getScore('mouthSmileLeft') + getScore('mouthSmileRight');
          const browInnerUp = getScore('browInnerUp');
          const browOuterUp = getScore('browOuterUpLeft') + getScore('browOuterUpRight');
          const browDown = getScore('browDownLeft') + getScore('browDownRight');

          let currentEmotion = 'neutral';
          if (smile > 0.8) currentEmotion = 'happy';
          else if (browInnerUp > 0.3 && browOuterUp < 0.1) currentEmotion = 'confused';
          else if (browDown > 0.6) currentEmotion = 'confused';

          emotionHistory.push(currentEmotion);
          if (emotionHistory.length > HISTORY_SIZE) emotionHistory.shift();

          const counts = { neutral: 0, happy: 0, confused: 0 };
          emotionHistory.forEach(e => counts[e]++);

          let stableEmotion = STATE.emotion;
          if (counts.happy > HISTORY_SIZE * 0.6) stableEmotion = 'happy';
          else if (counts.confused > HISTORY_SIZE * 0.6) stableEmotion = 'confused';
          else if (counts.neutral > HISTORY_SIZE * 0.6) stableEmotion = 'neutral';

          if (stableEmotion !== STATE.emotion) {
            STATE.emotion = stableEmotion;
            updateChips(STATE.emotion);

            emotionDebug.textContent = stableEmotion.charAt(0).toUpperCase() + stableEmotion.slice(1);

            if (stableEmotion !== 'neutral') {
              emotionLabel.textContent = `Detected: ${stableEmotion.charAt(0).toUpperCase() + stableEmotion.slice(1)}`;
              emotionLabel.className = stableEmotion === 'happy' ? 'emotion-happy' : 'emotion-confused';
              emotionLabel.style.opacity = 1;
            } else {
              emotionLabel.style.opacity = 0;
            }

            if (stableEmotion === 'happy') {
              STATE.happyPulse = Math.min(1, STATE.happyPulse + 0.03);
            }
          }
        }
      }
      window.requestAnimationFrame(predictWebcam);
    }

    init();

    // ===============================
    // INTRO VIDEO LOGIC
    // ===============================

    const intro = document.getElementById('intro');
    const introVideo = document.getElementById('intro-video');
    const skipIntroBtn = document.getElementById('skip-intro');
    const startSoundBtn = document.getElementById('start-sound');

    function finishIntro() {
      document.body.classList.add('intro-finished');

      // полностью убираем интро после анимации
      setTimeout(() => intro?.remove(), 900);
    }

    // когда видео закончилось
    introVideo.addEventListener('ended', finishIntro);

    // кнопка Skip
    skipIntroBtn.addEventListener('click', () => {
      introVideo.pause();
      finishIntro();
    });

    startSoundBtn.addEventListener('click', async () => {
      try {
        introVideo.muted = false;
        introVideo.volume = 1;
        await introVideo.play();
        startSoundBtn.style.display = 'none';
      } catch (e) {
        console.warn('Sound enable blocked:', e);
      }
    });
  </script>
</body>
</html>
